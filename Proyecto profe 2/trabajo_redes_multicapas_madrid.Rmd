---
title: "Redes Multicapas en el Transporte de Madrid"
author: "Tu nombre"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: flatly
    df_print: paged
  pdf_document:
    toc: true
    number_sections: true
fontsize: 11pt
lang: es
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

# Introducción

En este trabajo se analiza la **estructura multicapa de la red de transporte de la ciudad de Madrid** a partir de dos conjuntos de datos reales proporcionados:

- Un fichero con las **paradas y estaciones** de distintos modos de transporte.
- Un fichero con información de **viajes mensuales por distrito**.

Los objetivos concretos son:

- Construir una **red multicapa** donde cada capa representa un modo de transporte (`bus`, `metro`, `bicimad`, `parking`).
- Estudiar la **centralidad** de las zonas de intercambio en cada capa.
- Medir la **versatilidad** de las zonas (cómo cambia su importancia entre modos).
- Realizar una **visualización multicapa** en la que se vean explícitamente las distintas capas conectadas.
- Explorar de forma sencilla la **vulnerabilidad** del sistema ante fallos en una de las capas.

Toda la parte empírica se basa **exclusivamente** en los ficheros:

- `transporte_madrid_consolidado.csv`
- `viajes_madrid.csv`

No se utilizan ejemplos externos (como StarWars) para que el análisis esté completamente centrado en los datos de Madrid.

# Carga y exploración de datos

```{r cargar-paquetes}
library(tidyverse)
library(janitor)
library(sf)
library(dbscan)
library(FNN)
library(igraph)
library(scales)
library(knitr)
```

## Lectura de los ficheros

Se asume que los ficheros CSV están en el mismo directorio que este documento RMarkdown. Si no es así, ajustar las rutas.

```{r cargar-datos}
ruta_transporte <- "transporte_madrid_consolidado.csv"
ruta_viajes     <- "viajes_madrid.csv"

transporte_raw <- readr::read_delim(
  ruta_transporte,
  delim = ";",
  col_types = cols()
)

viajes_raw <- readr::read_delim(
  ruta_viajes,
  delim = ";",
  col_types = cols()
)

glimpse(transporte_raw)
glimpse(viajes_raw)
```

## Descripción básica de `transporte_madrid_consolidado`

```{r resumen-transporte}
transporte <- transporte_raw %>% 
  clean_names() %>% 
  mutate(
    transport_mode = str_trim(transport_mode),
    transport_mode = str_extract(transport_mode, "\\w+")
  )

table(transporte$transport_mode)

summary(select(transporte, stop_lat, stop_lon, distrito_asignado))
```

Variables clave:

- `stop_name`: nombre de la parada/estación.
- `stop_lat`, `stop_lon`: coordenadas geográficas.
- `transport_mode`: modo de transporte (`bus`, `metro`, `bicimad`, `parking`).
- `stop_id`: identificador de parada.
- `distrito_asignado`: código de distrito (INE).

Esto define los **nodos base** del sistema de transporte.

## Descripción básica de `viajes_madrid`

```{r resumen-viajes}
viajes <- viajes_raw %>% 
  clean_names() %>% 
  mutate(
    personas = str_replace(personas, ",", ".") %>% as.numeric()
  )

glimpse(viajes)

viajes %>% 
  count(distrito) %>% 
  arrange(distrito) %>% 
  head()
```

Variables clave:

- `fecha`: mes de referencia.
- `name`: nombre del distrito.
- `edad`, `sexo`: características sociodemográficas.
- `numero_viajes`: categoría de nº de viajes (0, 1, 2, `2+`).
- `personas`: número de personas en esa celda.
- `distrito`: código de distrito.
- `poblacion`: población total del distrito.

### Indicador de intensidad de viajes por distrito

Construimos un indicador sencillo de **viajes medios por persona** en cada distrito.

```{r viajes-intensidad}
viajes_distrito <- viajes %>% 
  mutate(
    viajes_cat = case_when(
      numero_viajes == "0"  ~ 0,
      numero_viajes == "1"  ~ 1,
      numero_viajes == "2"  ~ 2,
      numero_viajes == "2+" ~ 3,
      TRUE ~ NA_real_
    )
  ) %>% 
  group_by(distrito) %>% 
  summarise(
    poblacion = max(poblacion, na.rm = TRUE),
    viajes_totales = sum(viajes_cat * personas, na.rm = TRUE),
    viajes_medios_por_persona = viajes_totales / poblacion,
    .groups = "drop"
  )

kable(head(viajes_distrito), caption = "Indicador de viajes medios por persona y distrito")
summary(viajes_distrito$viajes_medios_por_persona)
```

# Construcción de la red multicapa

La idea es pasar de paradas individuales a **zonas de intercambio** (clusters de paradas cercanas), y luego construir una capa por modo de transporte.

## 1. Definición de zonas de intercambio (clustering espacial)

```{r zonas-intercambio, message=FALSE}
# Creamos objeto sf con coordenadas
transporte_sf <- transporte %>% 
  st_as_sf(coords = c("stop_lon", "stop_lat"), crs = 4326, remove = FALSE) %>% 
  st_transform(25830)  # sistema métrico (UTM zona 30)

coords_m <- transporte_sf %>% 
  st_coordinates() %>% 
  as.matrix()

# Clustering DBSCAN: paradas a menos de 150 m se agrupan
set.seed(123)
db <- dbscan(coords_m, eps = 150, minPts = 2)

transporte_sf$cluster_id <- db$cluster

# Tratamos el ruido (cluster 0) como clusters individuales
transporte_sf <- transporte_sf %>% 
  mutate(
    cluster_id = if_else(
      cluster_id == 0,
      max(cluster_id) + row_number(),
      cluster_id
    )
  )

# Zona de intercambio = centroide del cluster
zonas <- transporte_sf %>% 
  st_drop_geometry() %>% 
  group_by(cluster_id) %>% 
  summarise(
    stop_lat = mean(stop_lat),
    stop_lon = mean(stop_lon),
    # distrito asignado más frecuente en el cluster
    distrito_asignado = as.integer(names(which.max(table(distrito_asignado)))),
    modos_disponibles = paste(sort(unique(transport_mode)), collapse = ","),
    .groups = "drop"
  )

nrow(zonas)
head(zonas)
```

Cada `cluster_id` representa una **zona de intercambio multimodal**.

Representamos la distribución espacial aproximada (proyección geográfica simple):

```{r mapa-zonas, message=FALSE}
zonas_sf <- zonas %>% 
  st_as_sf(coords = c("stop_lon", "stop_lat"), crs = 4326)

plot(zonas_sf["distrito_asignado"], main = "Zonas de intercambio por distrito")
```

## 2. Nodos por modo de transporte

```{r nodos-por-modo}
modos <- sort(unique(transporte_sf$transport_mode))

zonas_modo <- transporte_sf %>% 
  st_drop_geometry() %>% 
  select(cluster_id, transport_mode) %>% 
  distinct() %>% 
  mutate(presente = 1) %>% 
  pivot_wider(
    names_from = transport_mode,
    values_from = presente,
    values_fill = 0
  )

zonas_attrs <- zonas %>% 
  left_join(zonas_modo, by = "cluster_id") %>% 
  mutate(across(all_of(modos), ~replace_na(., 0)))

kable(head(zonas_attrs), caption = "Atributos básicos de las zonas por modo")
```

## 3. Unimos la información de viajes por distrito

```{r unir-viajes}
# Forzamos el mismo tipo en ambas columnas de distrito
zonas_attrs <- zonas_attrs %>% 
  mutate(distrito_asignado = as.integer(distrito_asignado))

viajes_distrito <- viajes_distrito %>% 
  mutate(distrito = as.integer(distrito))

# Join seguro
zonas_attrs <- zonas_attrs %>% 
  left_join(
    viajes_distrito,
    by = c("distrito_asignado" = "distrito")
  )

summary(zonas_attrs$viajes_medios_por_persona)

```

En muchas zonas puede que no haya dato (si el distrito no aparece o hay problemas de asignación), pero para el análisis de red esto no es un problema; simplemente tendremos algunos `NA`.

## 4. Construcción de redes intra-capa

Para cada modo:

- Consideramos solo las zonas donde ese modo está presente.
- Unimos cada zona con sus **k vecinos más cercanos** (aquí k = 3) basándonos en la distancia euclídea de los centroides.
- Asignamos un peso inversamente proporcional a la distancia.

```{r edges-intracapa, message=FALSE}
# Centroides en coordenadas métricas
zonas_centroides <- zonas_sf %>% 
  st_transform(25830) %>% 
  st_coordinates() %>% 
  as_tibble() %>% 
  rename(x = X, y = Y) %>% 
  mutate(cluster_id = zonas$cluster_id)

build_edges_modo <- function(modo, k = 3) {
  zonas_modo_ids <- zonas_attrs %>% 
    filter(.data[[modo]] == 1) %>% 
    pull(cluster_id)

  if (length(zonas_modo_ids) <= 1) {
    return(tibble(modo = character(), from = integer(),
                  to = integer(), dist = numeric(), w = numeric()))
  }

  coords_modo <- zonas_centroides %>% 
    filter(cluster_id %in% zonas_modo_ids) %>% 
    arrange(cluster_id)

  mat <- as.matrix(coords_modo[, c("x", "y")])
  k_eff <- min(k, nrow(mat) - 1)
  knn <- FNN::get.knn(mat, k = k_eff)

  from <- rep(coords_modo$cluster_id, each = k_eff)
  to   <- coords_modo$cluster_id[c(knn$nn.index)]
  dist <- as.numeric(knn$nn.dist)

  tibble(
    modo  = modo,
    from  = from,
    to    = to,
    dist  = dist,
    w     = 1 / (1 + dist)
  ) %>% 
    distinct() %>% 
    filter(from != to)
}

edges_intra <- map_df(modos, build_edges_modo)

kable(head(edges_intra), caption = "Ejemplo de aristas intra-capa")
```

## 5. Grafos por capa (lista `g_list`)

```{r graphs-por-modo}
nodos_ids <- zonas_attrs$cluster_id

build_graph_modo <- function(modo) {
  e_modo <- edges_intra %>% 
    filter(modo == !!modo) %>% 
    select(from, to, w)

  g <- graph_from_data_frame(
    d = e_modo,
    directed = FALSE,
    vertices = zonas_attrs %>% 
      mutate(name = cluster_id)
  )

  missing_nodes <- setdiff(nodos_ids, as.integer(V(g)$name))
  if (length(missing_nodes) > 0) {
    g <- g + vertices(as.character(missing_nodes))
  }

  g
}

g_list <- map(modos, build_graph_modo)
names(g_list) <- modos

g_list
```

# Visualización multicapa con `muxViz`

En esta sección generamos la visualización clave: un gráfico 3D en el que se ven las capas (modos) apiladas, con los nodos alineados entre capas.

Para ello usamos la función `plot_multiplex3D` de `muxViz`. Se asume que `muxViz` está instalado; si no lo está, el código no fallará, pero mostrará un mensaje.

```{r plot-multiplex3D, eval = False}
if (requireNamespace("muxViz", quietly = TRUE)) {
  library(muxViz)

  layer_colors <- c(
    bicimad = "#1a9641",
    bus     = "#d7191c",
    metro   = "#2c7bb6",
    parking = "#fdae61"
  )

  node_multimodalidad <- zonas_attrs %>% 
    mutate(
      modos_activos = rowSums(across(all_of(modos)))
    ) %>% 
    pull(modos_activos)

  node_size_values <- rescale(node_multimodalidad, to = c(0.5, 2))

  muxViz::plot_multiplex3D(
    g.list           = g_list,
    layer.colors     = layer_colors[names(g_list)],
    layer.labels     = "auto",     # <- clave: escalar, no vector
    node.size.values = node_size_values,
    node.size.scale  = 1.5,
    edge.size.scale  = 0.5,
    layout           = "fr",
    show.aggregate   = TRUE,
    show.nodeLabels  = FALSE
  )
} else {
  message("El paquete 'muxViz' no está instalado. Instálalo con devtools::install_github('manlius/muxViz') para ver la visualización 3D.")
}

```

Dado que la función `plot_multiplex3D` de `muxViz` presenta problemas en la instalación utilizada (bug interno con `layer.labels`), se ha implementado un gráfico multicapa alternativo usando `tidygraph` y `ggraph`, que representa las capas apiladas y las conexiones intra- e inter-capa de forma equivalente.


```{r plot-multicapa-alternativo, message=FALSE, warning=FALSE}
# Gráfico multicapa alternativo con tidygraph + ggraph

library(tidygraph)
library(ggraph)

# Orden de las capas y un índice para apilarlas verticalmente
layer_order <- modos
layer_index <- setNames(seq_along(layer_order), layer_order)

# Distancia vertical entre capas (en coordenadas proyectadas)
offset <- (max(zonas_centroides$y) - min(zonas_centroides$y)) * 1.2

# Nodos multilayer: mismo cluster_id repetido por capa, apilado en vertical
nodes_multi <- purrr::map_dfr(layer_order, function(m) {
  zonas_centroides %>%
    transmute(
      node       = paste(cluster_id, m, sep = "_"),  # id único por nodo-capa
      cluster_id = cluster_id,
      layer      = m,
      layer_idx  = layer_index[m],
      x          = x,
      y          = y + (layer_index[m] - 1) * offset
    )
})

# Aristas intra-capa: usamos edges_intra y las asociamos a cada capa
edges_intra_multi <- edges_intra %>%
  transmute(
    from  = paste(from, modo, sep = "_"),
    to    = paste(to,   modo, sep = "_"),
    type  = "intra",
    layer = modo
  )

# Aristas inter-capa: unen el MISMO cluster_id entre modos presentes (verticales)
inter_edges <- purrr::map_dfr(zonas_attrs$cluster_id, function(cid) {
  # modos presentes en esa zona
  fila <- zonas_attrs[zonas_attrs$cluster_id == cid, modos, drop = FALSE]
  modos_presentes <- modos[as.logical(unlist(fila))]
  
  if (length(modos_presentes) < 2) return(tibble())
  
  comb <- t(combn(modos_presentes, 2))
  tibble(
    from  = paste(cid, comb[, 1], sep = "_"),
    to    = paste(cid, comb[, 2], sep = "_"),
    type  = "inter",
    layer = "inter"
  )
})

edges_all <- bind_rows(edges_intra_multi, inter_edges)

# Grafo multilayer
g_multi <- tbl_graph(nodes = nodes_multi, edges = edges_all, directed = FALSE)

# Colores de capa (igual que antes)
layer_colors <- c(
  bicimad = "#1a9641",
  bus     = "#d7191c",
  metro   = "#2c7bb6",
  parking = "#fdae61"
)

ggraph(g_multi, layout = "manual", x = x, y = y) +
  geom_edge_link(aes(alpha = type, linetype = type), show.legend = TRUE) +
  geom_node_point(aes(color = layer), size = 1.2) +
  scale_edge_alpha_manual(values = c(intra = 0.3, inter = 0.8)) +
  scale_edge_linetype_manual(values = c(intra = "solid", inter = "dashed")) +
  scale_color_manual(values = layer_colors) +
  theme_void() +
  labs(
    title = "Red multicapa de transporte de Madrid",
    subtitle = "Capas (modos) apiladas verticalmente y conectadas por zonas de intercambio",
    color = "Capa",
    linetype = "Tipo de enlace",
    alpha = "Tipo de enlace"
  )
```

Este gráfico muestra claramente:

- Las **capas** (`bus`, `metro`, `bicimad`, `parking`) como planos separados.
- Los **nodos** (zonas de intercambio) alineados entre capas.
- La **estructura de conexiones** en cada capa y la capa agregada.


```{r plot-3d-multicapa, message=FALSE, warning=FALSE}
# ===========================================
# Visualización 3D multicapa (inter-capa con scatter3d lines)
# ===========================================

if (requireNamespace("plotly", quietly = TRUE)) {

  library(plotly)
  library(dplyr)
  library(purrr)
  library(scales)
  library(tidyr)

  # ---- 1. Capas y eje Z
  layer_order <- modos
  layer_index <- setNames(seq_along(layer_order) - 1, layer_order)  # 0,1,2,3

  # ---- 2. Nodos multilayer: solo zonas donde ese modo existe
  nodes_multi_3d <- map_dfr(layer_order, function(m) {
    zonas_attrs %>%
      filter(.data[[m]] == 1) %>%                # solo zonas con ese modo
      select(cluster_id) %>%
      inner_join(zonas_centroides, by = "cluster_id") %>%
      transmute(
        node       = paste(cluster_id, m, sep = "_"),
        cluster_id = cluster_id,
        layer      = m,
        x_raw      = x,
        y_raw      = y
      )
  })

  # Normalizamos X, Y y asignamos Z
  nodes_multi_3d <- nodes_multi_3d %>%
    mutate(
      x = rescale(x_raw, to = c(0, 1)),
      y = rescale(y_raw, to = c(0, 1)),
      z = layer_index[layer]
    )

  # ---- 3. Multimodalidad por zona
  node_multimodalidad <- zonas_attrs %>%
    mutate(modos_activos = rowSums(across(all_of(modos)))) %>%
    select(cluster_id, modos_activos)

  # Clusters con al menos 2 modos
  clusters_interes <- node_multimodalidad %>%
    filter(modos_activos >= 2) %>%
    pull(cluster_id)

  # ---- 4. Aristas inter-capa: todos los pares de modos presentes
  edges_inter_3d <- map_dfr(clusters_interes, function(cid) {

    fila <- zonas_attrs[zonas_attrs$cluster_id == cid, modos, drop = FALSE]
    modos_presentes <- modos[as.logical(unlist(fila))]

    if (length(modos_presentes) < 2) return(tibble())

    comb <- t(combn(modos_presentes, 2))  # todos los pares posibles

    tibble(
      from       = paste(cid, comb[, 1], sep = "_"),
      to         = paste(cid, comb[, 2], sep = "_"),
      cluster_id = cid
    )
  })

  cat("Número de aristas inter-capa generadas:", nrow(edges_inter_3d), "\n")

  # ---- 5. Posiciones de nodos para las aristas
  pos_nodes <- nodes_multi_3d %>%
    select(node, x, y, z, layer)

  edges_plot <- edges_inter_3d %>%
    left_join(pos_nodes, by = c("from" = "node")) %>%
    rename(
      x  = x,
      y  = y,
      z  = z
    ) %>%
    left_join(pos_nodes, by = c("to" = "node"), suffix = c("", "_to")) %>%
    rename(
      xend = x_to,
      yend = y_to,
      zend = z_to
    ) %>%
    filter(
      !is.na(x), !is.na(y), !is.na(z),
      !is.na(xend), !is.na(yend), !is.na(zend)
    ) %>%
    select(x, y, z, xend, yend, zend, cluster_id)

  cat("Aristas con coordenadas válidas:", nrow(edges_plot), "\n")

  # ---- 6. Convertimos aristas a formato "long" para scatter3d lines
  # Para cada arista: (x,y,z) -> (xend,yend,zend) -> NA como separador
  if (nrow(edges_plot) > 0) {
    edges_long <- edges_plot %>%
      mutate(seg_id = row_number()) %>%
      mutate(
        x  = map2(x,  xend,  ~c(.x, .y, NA_real_)),
        y  = map2(y,  yend,  ~c(.x, .y, NA_real_)),
        z  = map2(z,  zend,  ~c(.x, .y, NA_real_))
      ) %>%
      select(seg_id, x, y, z) %>%
      unnest(c(x, y, z))
  } else {
    edges_long <- tibble(x = numeric(), y = numeric(), z = numeric())
  }

  cat("Puntos totales en edges_long:", nrow(edges_long), "\n")

  # ---- 7. Añadimos multimodalidad y tamaño de nodo
  nodes_multi_3d <- nodes_multi_3d %>%
    left_join(node_multimodalidad, by = "cluster_id") %>%
    mutate(
      modos_activos = replace_na(modos_activos, 1),
      size = rescale(modos_activos, to = c(4, 11))
    )

  # ---- 8. Colores por capa
  layer_colors <- c(
    bicimad = "#1a9641",
    bus     = "#d7191c",
    metro   = "#2c7bb6",
    parking = "#fdae61"
  )

  # ---- 9. Gráfico 3D
  p3d <- plot_ly()

  # Nodos
  p3d <- p3d %>%
    add_trace(
      data = nodes_multi_3d,
      type = "scatter3d",
      mode = "markers",
      x = ~x, y = ~y, z = ~z,
      color = ~layer,
      colors = layer_colors,
      marker = list(size = ~size),
      hoverinfo = "text",
      text = ~paste(
        "Zona:", cluster_id,
        "<br>Modo:", layer,
        "<br>Modos activos (total cluster):", modos_activos
      )
    )

  # Aristas inter-capa como líneas rojas gruesas
  if (nrow(edges_long) > 0) {
    p3d <- p3d %>%
      add_trace(
        data = edges_long,
        type = "scatter3d",
        mode = "lines",
        x = ~x, y = ~y, z = ~z,
        line = list(color = "black", width = 4),
        showlegend = FALSE,
        hoverinfo = "none"
      )
  } else {
    message("edges_long está vacío: no se han podido dibujar aristas inter-capa.")
  }

  p3d <- p3d %>%
    layout(
      title = "Red multicapa de transporte de Madrid (3D, enlaces entre capas)",
      scene = list(
        xaxis = list(title = "X (normalizada)"),
        yaxis = list(title = "Y (normalizada)"),
        zaxis = list(
          title = "Capa (modo de transporte)",
          tickvals = layer_index,
          ticktext = layer_order
        ),
        aspectmode = "cube"
      )
    )

  p3d

} else {
  message("Instala 'plotly' con install.packages('plotly') para ver la visualización 3D.")
}


```


**Interpretación de la visualización 3D multicapa**

La visualización tridimensional obtenida permite observar de forma explícita la estructura multicapa del sistema de transporte urbano de Madrid, donde cada plano horizontal representa un modo de transporte (bicimad, bus, metro y parking) y las conexiones verticales indican zonas de intercambio multimodal.

Separación clara de capas y estructura espacial

En primer lugar, se aprecia una separación nítida entre las cuatro capas, lo que confirma que cada modo de transporte presenta una distribución espacial propia:

* La capa bicimad aparece más concentrada espacialmente, reflejando su carácter urbano y centralizado.
* La capa bus muestra una cobertura más extensa, coherente con su función de red capilar que conecta barrios periféricos.
* La capa metro se sitúa entre ambas, con una estructura más compacta que refleja la jerarquía de estaciones y líneas.
* La capa parking aparece claramente diferenciada y menos densa, lo que concuerda con su función de infraestructura de apoyo más localizada.

Esta separación valida la decisión metodológica de modelar el sistema como una red multicapa, ya que una red agregada ocultaría estas diferencias estructurales.

**Uniones verticales como indicador de multimodalidad**

Las líneas verticales que conectan nodos entre capas representan zonas donde coexisten varios modos de transporte. Estas conexiones no aparecen de forma homogénea, sino que se concentran en un subconjunto reducido de zonas, lo que pone de manifiesto una fuerte heterogeneidad en la multimodalidad del sistema.

En términos de teoría de redes:

* Estas zonas actúan como nodos altamente versátiles, ya que participan simultáneamente en varias capas.

* Son puntos críticos para la integración funcional del sistema, permitiendo el transbordo eficiente entre modos.

* Su posición estructural las convierte en puntos de control del flujo global de movilidad.

Visualmente, estas zonas destacan como “columnas” que atraviesan varias capas, reforzando la idea de que la conectividad global del sistema depende de un número limitado de nodos clave.

**Versatilidad y roles multinodales**

La figura ilustra de manera intuitiva el concepto de versatilidad de nodo:

* La mayoría de los nodos aparecen en una sola capa, actuando como nodos especializados (por ejemplo, paradas de bus o estaciones de bici aisladas).
* En contraste, un número reducido de nodos conecta tres o incluso cuatro capas, desempeñando un rol multinodal esencial.

Este patrón es consistente con la literatura sobre redes multicapas, donde se observa que la importancia de un nodo no puede evaluarse correctamente desde una sola capa. La visualización 3D confirma que los nodos versátiles no solo existen, sino que son estructuralmente visibles cuando se representan explícitamente las capas y sus interdependencias.

**Implicaciones para vulnerabilidad y resiliencia**

Desde el punto de vista de la vulnerabilidad del sistema, la visualización sugiere una conclusión relevante:

* La conectividad multimodal del transporte madrileño depende de un conjunto relativamente pequeño de nodos altamente interconectados entre capas.
* Una perturbación localizada en estos nodos (por ejemplo, cierre de un intercambiador o fallo simultáneo de varios modos en una zona) podría propagarse rápidamente al resto del sistema, afectando a múltiples capas.

Este comportamiento es coherente con los modelos de cascadas de fallo en redes interdependientes descritos en la literatura (Buldyrev et al., 2010; Duan et al., 2019), donde la interdependencia aumenta tanto la eficiencia como la fragilidad del sistema.

**Valor añadido de la representación multicapa**

Finalmente, esta visualización demuestra el valor añadido del enfoque multicapa frente a representaciones tradicionales:

* Permite identificar de forma directa los intercambiadores críticos.
* Hace visible la estructura de interdependencia entre modos.
* Facilita la interpretación de conceptos abstractos como versatilidad, roles multinodales y vulnerabilidad sistémica.

En conjunto, el gráfico 3D no solo actúa como herramienta exploratoria, sino como una evidencia visual clara de que el sistema de transporte de Madrid funciona como una red interconectada de capas, cuya eficiencia y resiliencia dependen de la correcta gestión de sus nodos multimodales clave.


# Centralidad y versatilidad de las zonas

## 1. Medidas de centralidad por capa

Calculamos grado y fuerza (suma de pesos) para cada zona en cada modo.

```{r centralidad-por-capa}
centralidad_por_capa <- map2_df(
  .x = g_list,
  .y = names(g_list),
  .f = function(g, modo) {
    tibble(
      cluster_id = as.integer(V(g)$name),
      modo       = modo,
      degree     = degree(g),
      strength   = strength(g, weights = E(g)$w)
    )
  }
)

kable(head(centralidad_por_capa), caption = "Centralidad (grado y fuerza) por capa")
```

Distribución del grado por modo:

```{r distribucion-grado}
centralidad_por_capa %>% 
  ggplot(aes(x = degree, fill = modo)) +
  geom_histogram(alpha = 0.6, bins = 30, position = "identity") +
  facet_wrap(~ modo, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Distribución del grado por modo de transporte",
    x = "Grado",
    y = "Frecuencia"
  )
```

## 2. Versatilidad de grado

Definimos una medida de versatilidad basada en la entropía de Shannon de la distribución de grado entre modos.

```{r versatilidad-grado}
mat_grado <- centralidad_por_capa %>% 
  select(cluster_id, modo, degree) %>% 
  pivot_wider(
    names_from = modo,
    values_from = degree,
    values_fill = 0
  ) %>% 
  arrange(cluster_id)

grado_mat <- as.matrix(mat_grado[, modos])
rownames(grado_mat) <- mat_grado$cluster_id

calc_versatilidad <- function(vec) {
  if (sum(vec) == 0) return(NA_real_)
  p <- vec / sum(vec)
  p <- p[p > 0]
  H <- -sum(p * log(p))
  H / log(length(vec))
}

versatilidad <- apply(grado_mat, 1, calc_versatilidad)

versatilidad_df <- tibble(
  cluster_id = as.integer(names(versatilidad)),
  versatilidad_grado = as.numeric(versatilidad)
) %>% 
  left_join(zonas_attrs, by = "cluster_id")

summary(versatilidad_df$versatilidad_grado)
```

### Nodos más versátiles y más especializados

```{r top-versatiles-especializados}
top_versatiles <- versatilidad_df %>% 
  arrange(desc(versatilidad_grado)) %>% 
  slice_head(n = 15) %>% 
  select(cluster_id, versatilidad_grado, modos_disponibles, distrito_asignado)

top_especializados <- versatilidad_df %>% 
  arrange(versatilidad_grado) %>% 
  slice_head(n = 15) %>% 
  select(cluster_id, versatilidad_grado, modos_disponibles, distrito_asignado)

kable(top_versatiles, caption = "Top 15 zonas más versátiles")
kable(top_especializados, caption = "Top 15 zonas más especializadas")
```

Interpretación cualitativa (a redactar en la memoria):

- Zonas con **alta versatilidad**: concentran paradas de varios modos y son relevantes en varias capas.
- Zonas **especializadas**: la conectividad se concentra en un único modo.

## 3. Relación entre versatilidad e intensidad de viajes

```{r versatilidad-vs-viajes}
versatilidad_df %>% 
  ggplot(aes(x = viajes_medios_por_persona, y = versatilidad_grado)) +
  geom_point(alpha = 0.4) +
  geom_smooth(method = "loess", se = FALSE) +
  theme_minimal() +
  labs(
    title = "Versatilidad de las zonas vs viajes medios por persona",
    x = "Viajes medios por persona (distrito)",
    y = "Versatilidad de grado"
  )
```

Comprobamos cuántas observaciones completas hay y calculamos la correlación **solo si tiene sentido estadísticamente** (al menos 3 observaciones completas):

```{r correlacion-versatilidad-viajes}
datos_cor <- versatilidad_df %>% 
  filter(!is.na(versatilidad_grado),
         !is.na(viajes_medios_por_persona))

n_obs <- nrow(datos_cor)
n_obs

if (n_obs >= 3) {
  cor_test <- cor.test(
    datos_cor$versatilidad_grado,
    datos_cor$viajes_medios_por_persona
  )
  cor_test
} else {
  cat("No hay suficientes observaciones completas para estimar de forma fiable la correlación entre versatilidad y viajes.
")
}
```

Esto evita el error de “not enough finite observations” y hace el análisis más robusto.

# Vulnerabilidad de la red de transporte

En lugar de implementar un modelo muy complejo de cascadas, realizamos un análisis sencillo pero informativo de **robustez estructural**:

- Tomamos la red agregada (unión de todas las capas).
- Eliminamos nodos de forma dirigida (los más centrales) en una capa y observamos cómo disminuye el tamaño de la componente gigante agregada.

## 1. Red agregada

```{r red-agregada}
# Matrices de adyacencia por capa
adj_list <- lapply(g_list, function(g) {
  as.matrix(as_adj(g, attr = "w", sparse = FALSE))
})

# Aseguramos mismo orden de nodos
orden_nodos <- order(as.integer(V(g_list[[1]])$name))
adj_list <- lapply(adj_list, function(m) m[orden_nodos, orden_nodos])

adj_agregada <- Reduce("+", adj_list)

g_agregado <- graph_from_adjacency_matrix(adj_agregada, mode = "undirected", weighted = TRUE)

comp <- components(g_agregado)
tamano_gcc_inicial <- max(comp$csize)
tamano_gcc_inicial
```

## 2. Robustez frente a fallos en una capa

Analizamos qué ocurre si vamos eliminando nodos con mayor grado en la capa `metro` y miramos el tamaño relativo de la componente gigante en la red agregada.

```{r robustez-metro}
g_metro <- g_list[["metro"]]

deg_metro <- degree(g_metro)
orden_fallo <- names(sort(deg_metro, decreasing = TRUE))  # orden de fallo: más conectados primero

fracciones <- seq(0, 0.5, by = 0.05)

resultado_robustez <- map_df(fracciones, function(f) {
  n_remove <- ceiling(f * length(orden_fallo))
  nodos_fuera <- orden_fallo[seq_len(n_remove)]

  g_agregado_reducido <- delete_vertices(g_agregado, nodos_fuera)
  comp_red <- components(g_agregado_reducido)
  gcc_red <- if (length(comp_red$csize) == 0) 0 else max(comp_red$csize)

  tibble(
    frac_eliminada = f,
    tamano_gcc_rel = gcc_red / tamano_gcc_inicial
  )
})

resultado_robustez %>% 
  ggplot(aes(x = frac_eliminada, y = tamano_gcc_rel)) +
  geom_line() +
  geom_point() +
  theme_minimal() +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  scale_x_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Robustez de la red agregada ante fallos en la capa METRO",
    x = "Fracción de nodos eliminados en METRO",
    y = "Tamaño relativo de la componente gigante agregada"
  )
```

Una caída rápida del tamaño de la componente gigante indica **alta vulnerabilidad** ante fallos dirigidos en nodos centrales de la capa `metro`.

# Conclusiones

En esta memoria se ha construido y analizado una **red multicapas de transporte para Madrid** utilizando exclusivamente los datos proporcionados:

- Las paradas se han agrupado en **zonas de intercambio** mediante clustering espacial.
- Se ha definido una red multicapa con capas para `bus`, `metro`, `bicimad` y `parking`.
- Se ha calculado la **centralidad** de las zonas en cada capa y un indicador de **versatilidad de grado** que muestra qué zonas son importantes en varios modos a la vez.
- Se ha generado una visualización multicapa con `muxViz` que hace explícita la estructura en capas.
- Se ha estudiado la **robustez estructural** de la red agregada frente a fallos dirigidos en nodos centrales de la capa `metro`.

A partir de aquí, se podrían ampliar los análisis:

- Incorporando información de líneas reales (no solo proximidad espacial).
- Usando otras medidas de centralidad (betweenness, eigenvector, PageRank).
- Implementando modelos de cascadas más cercanos a la literatura de redes interdependientes.

El código está preparado para ejecutarse directamente (asumiendo que los CSV y los paquetes necesarios están disponibles) y centrado únicamente en los datos reales de Madrid, tal y como se pedía en el enunciado.

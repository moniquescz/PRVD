left_join(zonas_modo, by = "cluster_id") %>%
mutate(across(all_of(modos), ~replace_na(., 0)))
kable(head(zonas_attrs), caption = "Atributos básicos de las zonas por modo")
# Forzamos el mismo tipo en ambas columnas de distrito
zonas_attrs <- zonas_attrs %>%
mutate(distrito_asignado = as.integer(distrito_asignado))
viajes_distrito <- viajes_distrito %>%
mutate(distrito = as.integer(distrito))
# Join seguro
zonas_attrs <- zonas_attrs %>%
left_join(
viajes_distrito,
by = c("distrito_asignado" = "distrito")
)
summary(zonas_attrs$viajes_medios_por_persona)
# Centroides en coordenadas métricas
zonas_centroides <- zonas_sf %>%
st_transform(25830) %>%
st_coordinates() %>%
as_tibble() %>%
rename(x = X, y = Y) %>%
mutate(cluster_id = zonas$cluster_id)
build_edges_modo <- function(modo, k = 3) {
zonas_modo_ids <- zonas_attrs %>%
filter(.data[[modo]] == 1) %>%
pull(cluster_id)
if (length(zonas_modo_ids) <= 1) {
return(tibble(modo = character(), from = integer(),
to = integer(), dist = numeric(), w = numeric()))
}
coords_modo <- zonas_centroides %>%
filter(cluster_id %in% zonas_modo_ids) %>%
arrange(cluster_id)
mat <- as.matrix(coords_modo[, c("x", "y")])
k_eff <- min(k, nrow(mat) - 1)
knn <- FNN::get.knn(mat, k = k_eff)
from <- rep(coords_modo$cluster_id, each = k_eff)
to   <- coords_modo$cluster_id[c(knn$nn.index)]
dist <- as.numeric(knn$nn.dist)
tibble(
modo  = modo,
from  = from,
to    = to,
dist  = dist,
w     = 1 / (1 + dist)
) %>%
distinct() %>%
filter(from != to)
}
edges_intra <- map_df(modos, build_edges_modo)
kable(head(edges_intra), caption = "Ejemplo de aristas intra-capa")
nodos_ids <- zonas_attrs$cluster_id
build_graph_modo <- function(modo) {
e_modo <- edges_intra %>%
filter(modo == !!modo) %>%
select(from, to, w)
g <- graph_from_data_frame(
d = e_modo,
directed = FALSE,
vertices = zonas_attrs %>%
mutate(name = cluster_id)
)
missing_nodes <- setdiff(nodos_ids, as.integer(V(g)$name))
if (length(missing_nodes) > 0) {
g <- g + vertices(as.character(missing_nodes))
}
g
}
g_list <- map(modos, build_graph_modo)
names(g_list) <- modos
g_list
# Gráfico multicapa alternativo con tidygraph + ggraph
library(tidygraph)
library(ggraph)
# Orden de las capas y un índice para apilarlas verticalmente
layer_order <- modos
layer_index <- setNames(seq_along(layer_order), layer_order)
# Distancia vertical entre capas (en coordenadas proyectadas)
offset <- (max(zonas_centroides$y) - min(zonas_centroides$y)) * 1.2
# Nodos multilayer: mismo cluster_id repetido por capa, apilado en vertical
nodes_multi <- purrr::map_dfr(layer_order, function(m) {
zonas_centroides %>%
transmute(
node       = paste(cluster_id, m, sep = "_"),  # id único por nodo-capa
cluster_id = cluster_id,
layer      = m,
layer_idx  = layer_index[m],
x          = x,
y          = y + (layer_index[m] - 1) * offset
)
})
# Aristas intra-capa: usamos edges_intra y las asociamos a cada capa
edges_intra_multi <- edges_intra %>%
transmute(
from  = paste(from, modo, sep = "_"),
to    = paste(to,   modo, sep = "_"),
type  = "intra",
layer = modo
)
# Aristas inter-capa: unen el MISMO cluster_id entre modos presentes (verticales)
inter_edges <- purrr::map_dfr(zonas_attrs$cluster_id, function(cid) {
# modos presentes en esa zona
fila <- zonas_attrs[zonas_attrs$cluster_id == cid, modos, drop = FALSE]
modos_presentes <- modos[as.logical(unlist(fila))]
if (length(modos_presentes) < 2) return(tibble())
comb <- t(combn(modos_presentes, 2))
tibble(
from  = paste(cid, comb[, 1], sep = "_"),
to    = paste(cid, comb[, 2], sep = "_"),
type  = "inter",
layer = "inter"
)
})
edges_all <- bind_rows(edges_intra_multi, inter_edges)
# Grafo multilayer
g_multi <- tbl_graph(nodes = nodes_multi, edges = edges_all, directed = FALSE)
# Colores de capa (igual que antes)
layer_colors <- c(
bicimad = "#1a9641",
bus     = "#d7191c",
metro   = "#2c7bb6",
parking = "#fdae61"
)
ggraph(g_multi, layout = "manual", x = x, y = y) +
geom_edge_link(aes(alpha = type, linetype = type), show.legend = TRUE) +
geom_node_point(aes(color = layer), size = 1.2) +
scale_edge_alpha_manual(values = c(intra = 0.3, inter = 0.8)) +
scale_edge_linetype_manual(values = c(intra = "solid", inter = "dashed")) +
scale_color_manual(values = layer_colors) +
theme_void() +
labs(
title = "Red multicapa de transporte de Madrid",
subtitle = "Capas (modos) apiladas verticalmente y conectadas por zonas de intercambio",
color = "Capa",
linetype = "Tipo de enlace",
alpha = "Tipo de enlace"
)
# ===========================================
# Visualización 3D multicapa (inter-capa con scatter3d lines)
# ===========================================
if (requireNamespace("plotly", quietly = TRUE)) {
library(plotly)
library(dplyr)
library(purrr)
library(scales)
library(tidyr)
# ---- 1. Capas y eje Z
layer_order <- modos
layer_index <- setNames(seq_along(layer_order) - 1, layer_order)  # 0,1,2,3
# ---- 2. Nodos multilayer: solo zonas donde ese modo existe
nodes_multi_3d <- map_dfr(layer_order, function(m) {
zonas_attrs %>%
filter(.data[[m]] == 1) %>%                # solo zonas con ese modo
select(cluster_id) %>%
inner_join(zonas_centroides, by = "cluster_id") %>%
transmute(
node       = paste(cluster_id, m, sep = "_"),
cluster_id = cluster_id,
layer      = m,
x_raw      = x,
y_raw      = y
)
})
# Normalizamos X, Y y asignamos Z
nodes_multi_3d <- nodes_multi_3d %>%
mutate(
x = rescale(x_raw, to = c(0, 1)),
y = rescale(y_raw, to = c(0, 1)),
z = layer_index[layer]
)
# ---- 3. Multimodalidad por zona
node_multimodalidad <- zonas_attrs %>%
mutate(modos_activos = rowSums(across(all_of(modos)))) %>%
select(cluster_id, modos_activos)
# Clusters con al menos 2 modos
clusters_interes <- node_multimodalidad %>%
filter(modos_activos >= 2) %>%
pull(cluster_id)
# ---- 4. Aristas inter-capa: todos los pares de modos presentes
edges_inter_3d <- map_dfr(clusters_interes, function(cid) {
fila <- zonas_attrs[zonas_attrs$cluster_id == cid, modos, drop = FALSE]
modos_presentes <- modos[as.logical(unlist(fila))]
if (length(modos_presentes) < 2) return(tibble())
comb <- t(combn(modos_presentes, 2))  # todos los pares posibles
tibble(
from       = paste(cid, comb[, 1], sep = "_"),
to         = paste(cid, comb[, 2], sep = "_"),
cluster_id = cid
)
})
cat("Número de aristas inter-capa generadas:", nrow(edges_inter_3d), "\n")
# ---- 5. Posiciones de nodos para las aristas
pos_nodes <- nodes_multi_3d %>%
select(node, x, y, z, layer)
edges_plot <- edges_inter_3d %>%
left_join(pos_nodes, by = c("from" = "node")) %>%
rename(
x  = x,
y  = y,
z  = z
) %>%
left_join(pos_nodes, by = c("to" = "node"), suffix = c("", "_to")) %>%
rename(
xend = x_to,
yend = y_to,
zend = z_to
) %>%
filter(
!is.na(x), !is.na(y), !is.na(z),
!is.na(xend), !is.na(yend), !is.na(zend)
) %>%
select(x, y, z, xend, yend, zend, cluster_id)
cat("Aristas con coordenadas válidas:", nrow(edges_plot), "\n")
# ---- 6. Convertimos aristas a formato "long" para scatter3d lines
# Para cada arista: (x,y,z) -> (xend,yend,zend) -> NA como separador
if (nrow(edges_plot) > 0) {
edges_long <- edges_plot %>%
mutate(seg_id = row_number()) %>%
mutate(
x  = map2(x,  xend,  ~c(.x, .y, NA_real_)),
y  = map2(y,  yend,  ~c(.x, .y, NA_real_)),
z  = map2(z,  zend,  ~c(.x, .y, NA_real_))
) %>%
select(seg_id, x, y, z) %>%
unnest(c(x, y, z))
} else {
edges_long <- tibble(x = numeric(), y = numeric(), z = numeric())
}
cat("Puntos totales en edges_long:", nrow(edges_long), "\n")
# ---- 7. Añadimos multimodalidad y tamaño de nodo
nodes_multi_3d <- nodes_multi_3d %>%
left_join(node_multimodalidad, by = "cluster_id") %>%
mutate(
modos_activos = replace_na(modos_activos, 1),
size = rescale(modos_activos, to = c(4, 11))
)
# ---- 8. Colores por capa
layer_colors <- c(
bicimad = "#1a9641",
bus     = "#d7191c",
metro   = "#2c7bb6",
parking = "#fdae61"
)
# ---- 9. Gráfico 3D
p3d <- plot_ly()
# Nodos
p3d <- p3d %>%
add_trace(
data = nodes_multi_3d,
type = "scatter3d",
mode = "markers",
x = ~x, y = ~y, z = ~z,
color = ~layer,
colors = layer_colors,
marker = list(size = ~size),
hoverinfo = "text",
text = ~paste(
"Zona:", cluster_id,
"<br>Modo:", layer,
"<br>Modos activos (total cluster):", modos_activos
)
)
# Aristas inter-capa como líneas rojas gruesas
if (nrow(edges_long) > 0) {
p3d <- p3d %>%
add_trace(
data = edges_long,
type = "scatter3d",
mode = "lines",
x = ~x, y = ~y, z = ~z,
line = list(color = "black", width = 4),
showlegend = FALSE,
hoverinfo = "none"
)
} else {
message("edges_long está vacío: no se han podido dibujar aristas inter-capa.")
}
p3d <- p3d %>%
layout(
title = "Red multicapa de transporte de Madrid (3D, enlaces entre capas)",
scene = list(
xaxis = list(title = "X (normalizada)"),
yaxis = list(title = "Y (normalizada)"),
zaxis = list(
title = "Capa (modo de transporte)",
tickvals = layer_index,
ticktext = layer_order
),
aspectmode = "cube"
)
)
p3d
} else {
message("Instala 'plotly' con install.packages('plotly') para ver la visualización 3D.")
}
centralidad_por_capa <- map2_df(
.x = g_list,
.y = names(g_list),
.f = function(g, modo) {
tibble(
cluster_id = as.integer(V(g)$name),
modo       = modo,
degree     = degree(g),
strength   = strength(g, weights = E(g)$w)
)
}
)
kable(head(centralidad_por_capa), caption = "Centralidad (grado y fuerza) por capa")
centralidad_por_capa %>%
ggplot(aes(x = degree, fill = modo)) +
geom_histogram(alpha = 0.6, bins = 30, position = "identity") +
facet_wrap(~ modo, scales = "free_y") +
theme_minimal() +
labs(
title = "Distribución del grado por modo de transporte",
x = "Grado",
y = "Frecuencia"
)
mat_grado <- centralidad_por_capa %>%
select(cluster_id, modo, degree) %>%
pivot_wider(
names_from = modo,
values_from = degree,
values_fill = 0
) %>%
arrange(cluster_id)
grado_mat <- as.matrix(mat_grado[, modos])
rownames(grado_mat) <- mat_grado$cluster_id
calc_versatilidad <- function(vec) {
if (sum(vec) == 0) return(NA_real_)
p <- vec / sum(vec)
p <- p[p > 0]
H <- -sum(p * log(p))
H / log(length(vec))
}
versatilidad <- apply(grado_mat, 1, calc_versatilidad)
versatilidad_df <- tibble(
cluster_id = as.integer(names(versatilidad)),
versatilidad_grado = as.numeric(versatilidad)
) %>%
left_join(zonas_attrs, by = "cluster_id")
summary(versatilidad_df$versatilidad_grado)
top_versatiles <- versatilidad_df %>%
arrange(desc(versatilidad_grado)) %>%
slice_head(n = 15) %>%
select(cluster_id, versatilidad_grado, modos_disponibles, distrito_asignado)
top_especializados <- versatilidad_df %>%
arrange(versatilidad_grado) %>%
slice_head(n = 15) %>%
select(cluster_id, versatilidad_grado, modos_disponibles, distrito_asignado)
kable(top_versatiles, caption = "Top 15 zonas más versátiles")
kable(top_especializados, caption = "Top 15 zonas más especializadas")
versatilidad_df %>%
ggplot(aes(x = viajes_medios_por_persona, y = versatilidad_grado)) +
geom_point(alpha = 0.4) +
geom_smooth(method = "loess", se = FALSE) +
theme_minimal() +
labs(
title = "Versatilidad de las zonas vs viajes medios por persona",
x = "Viajes medios por persona (distrito)",
y = "Versatilidad de grado"
)
datos_cor <- versatilidad_df %>%
filter(!is.na(versatilidad_grado),
!is.na(viajes_medios_por_persona))
n_obs <- nrow(datos_cor)
n_obs
if (n_obs >= 3) {
cor_test <- cor.test(
datos_cor$versatilidad_grado,
datos_cor$viajes_medios_por_persona
)
cor_test
} else {
cat("No hay suficientes observaciones completas para estimar de forma fiable la correlación entre versatilidad y viajes.
")
}
# Matrices de adyacencia por capa
adj_list <- lapply(g_list, function(g) {
as.matrix(as_adj(g, attr = "w", sparse = FALSE))
})
# Aseguramos mismo orden de nodos
orden_nodos <- order(as.integer(V(g_list[[1]])$name))
adj_list <- lapply(adj_list, function(m) m[orden_nodos, orden_nodos])
adj_agregada <- Reduce("+", adj_list)
g_agregado <- graph_from_adjacency_matrix(adj_agregada, mode = "undirected", weighted = TRUE)
comp <- components(g_agregado)
tamano_gcc_inicial <- max(comp$csize)
tamano_gcc_inicial
g_metro <- g_list[["metro"]]
deg_metro <- degree(g_metro)
orden_fallo <- names(sort(deg_metro, decreasing = TRUE))  # orden de fallo: más conectados primero
fracciones <- seq(0, 0.5, by = 0.05)
resultado_robustez <- map_df(fracciones, function(f) {
n_remove <- ceiling(f * length(orden_fallo))
nodos_fuera <- orden_fallo[seq_len(n_remove)]
g_agregado_reducido <- delete_vertices(g_agregado, nodos_fuera)
comp_red <- components(g_agregado_reducido)
gcc_red <- if (length(comp_red$csize) == 0) 0 else max(comp_red$csize)
tibble(
frac_eliminada = f,
tamano_gcc_rel = gcc_red / tamano_gcc_inicial
)
})
resultado_robustez %>%
ggplot(aes(x = frac_eliminada, y = tamano_gcc_rel)) +
geom_line() +
geom_point() +
theme_minimal() +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
scale_x_continuous(labels = percent_format(accuracy = 1)) +
labs(
title = "Robustez de la red agregada ante fallos en la capa METRO",
x = "Fracción de nodos eliminados en METRO",
y = "Tamaño relativo de la componente gigante agregada"
)
library(dplyr)
library(knitr)
viajes_distrito <- viajes %>%
mutate(
# Pasamos las categorías de nº de viajes a un valor numérico aproximado
viajes_cat = dplyr::case_when(
numero_viajes == "0"  ~ 0,
numero_viajes == "1"  ~ 1,
numero_viajes == "2"  ~ 2,
numero_viajes == "2+" ~ 3,
TRUE ~ NA_real_
)
) %>%
group_by(distrito) %>%
summarise(
# Total de personas (peso) en el distrito
personas_totales = sum(personas, na.rm = TRUE),
# Total de viajes ponderados
viajes_totales   = sum(viajes_cat * personas, na.rm = TRUE),
# Viajes medios por persona
viajes_medios_por_persona = viajes_totales / personas_totales,
.groups = "drop"
)
kable(
head(viajes_distrito),
digits = 3,
caption = "Viajes medios diarios por persona y distrito"
)
summary(viajes_distrito$viajes_medios_por_persona)
set.seed(123)
simular_ataque <- function(g, estrategia = c("dirigido", "aleatorio"),
fracciones = seq(0, 0.5, by = 0.05)) {
estrategia <- match.arg(estrategia)
n <- vcount(g)
resultados <- tibble()
if (estrategia == "dirigido") {
orden <- names(sort(degree(g), decreasing = TRUE))
} else {
orden <- sample(V(g)$name)
}
for (f in fracciones) {
k <- ceiling(f * n)
g_tmp <- delete_vertices(g, orden[seq_len(k)])
gcc <- if (vcount(g_tmp) == 0) 0 else max(components(g_tmp)$csize)
resultados <- bind_rows(
resultados,
tibble(
frac_eliminada = f,
tamano_gcc_rel = gcc / tamano_gcc_inicial,
estrategia = estrategia
)
)
}
resultados
}
res_dirigido  <- simular_ataque(g_agregado, "dirigido")
res_aleatorio <- simular_ataque(g_agregado, "aleatorio")
res_vuln <- bind_rows(res_dirigido, res_aleatorio)
ggplot(res_vuln,
aes(x = frac_eliminada, y = tamano_gcc_rel, color = estrategia)) +
geom_line(size = 1) +
geom_point() +
theme_minimal() +
labs(
x = "Fracción de nodos eliminados",
y = "Tamaño relativo de la componente gigante",
color = "Estrategia",
title = "Robustez de la red: ataque dirigido vs fallo aleatorio"
)
g_metro <- g_list[["metro"]]
deg_metro <- degree(g_metro)
orden_fallo <- names(sort(deg_metro, decreasing = TRUE))  # orden de fallo: más conectados primero
fracciones <- seq(0, 0.5, by = 0.05)
resultado_robustez <- map_df(fracciones, function(f) {
n_remove <- ceiling(f * length(orden_fallo))
nodos_fuera <- orden_fallo[seq_len(n_remove)]
g_agregado_reducido <- delete_vertices(g_agregado, nodos_fuera)
comp_red <- components(g_agregado_reducido)
gcc_red <- if (length(comp_red$csize) == 0) 0 else max(comp_red$csize)
tibble(
frac_eliminada = f,
tamano_gcc_rel = gcc_red / tamano_gcc_inicial
)
})
resultado_robustez %>%
ggplot(aes(x = frac_eliminada, y = tamano_gcc_rel)) +
geom_line() +
geom_point() +
theme_minimal() +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
scale_x_continuous(labels = percent_format(accuracy = 1)) +
labs(
title = "Robustez de la red agregada ante fallos en la capa METRO",
x = "Fracción de nodos eliminados en METRO",
y = "Tamaño relativo de la componente gigante agregada"
)
